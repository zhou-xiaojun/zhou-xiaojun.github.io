[{"id":"ea1216a9cc289837d7b990c138bab379","title":"运行一个简单的Flask","content":"Flask程序编写老规矩,万物皆可helloworld!\n创建helloworld.py文件\n# 导入Flask类\nfrom flask import Flask\n\n# Flask类接收一个参数__name__\napp &#x3D; Flask(__name__)\n\n# 装饰器的作用是将路由映射到视图函数index\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;Hello World&#39;\n\n# Flask应用程序实例的run方法启动WEB服务器\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n\n启动运行python helloworld.py\n\n\n\n\n\n\n\n提示\n如果使用pychram运行.像正常运行普通的python程序一样即可\n到这里,已经完成了一个最简单的flask程序\n\n\n\n参数说明Flask对象初始化参数Flask程序实力实例在创建的时候,需要默认传入当前Flask程序所指定的包(模块),接下来就来详细查看一下Flask应用程序在创建的时候一些需要我们关注的参数:\n\nImport_name\nFlask程序所在的包(模块),传_name_就可以\n这个参数可以决定Flask在访问静态文件时查找的路径\n\n\nstatic_url_path\n静态文件访问路径,可以不传,默认为：/ + static_folder\n\n\nstatic_folder\n静态文件存储的文件夹,可以不传,默认为 static\n\n\ntemplate_folder\n模板文件存储的文件夹,可以不传,默认为 templates\n\n\n\n默认参数情况下\napp &#x3D; Flask(__name__)\n\n文件目录\n----\n  |---static\n  |     |--- 1.png\n  |---helloworld.py\n\n修改参数的情况下\napp &#x3D; Flask(__name__, static_url_path&#x3D;&#39;&#x2F;url_path_param&#39;, static_folder&#x3D;&#39;folder_param&#39;)\n\n文件目录\n----\n  |---folder_param     # 此处目录名变化\n  |     |--- 1.png\n  |---helloworld.py\n\n访问127.0.0.1:5000/url_path_param/1.png才可以访问到图片\n\n应用程序配置参数对于Flask对象初始化参数仅仅设置的是Flask本身的属性,比如:\n\nFlask从哪里读取静态文件\nFlask从哪里读取模板文件\n等等…\n\n应用程序配置参数设置的是一个Web应用工程的相关信息,比如:\n\n数据库的连接信息\n日志的配置信息\n自定义的配置信息(第三方插件,或者关于配置的常量变量)\n等等…\n\n\n\n\n\n\n\n提示\n作用就是集中管理项目的所有配置信息(敏感的配置信息建议单独从env环境变量中导入)\n\n\n使用方式Django将所有的配置信息都放到了settings.py文件中,而Flask就不一样.\nFlask将配置信息保存到了app.conifg属性中,该属性可以按照字典类型进行操作\n读取\napp.config.get(name)\napp.config[name]\n\n设置主要使用一下三种方式\n\n从配置对象中加载\napp.config.from_object(配置对象)\nclass DefaultConfig(object):\n    &quot;&quot;&quot;默认配置&quot;&quot;&quot;\n    SECRET_KEY &#x3D; &#39;秘钥&#39;\n\napp &#x3D; Flask(__name__)\n\napp.config.from_object(DefaultConfig)\n\n@app.route(&quot;&#x2F;&quot;)\ndef index():\n    print(app.config[&#39;SECRET_KEY&#39;])\n    return &quot;hello world&quot;\n\n\n\n\n\n\n\n提示\n这里的命名是约定俗称的,都是按照环境来命名,你可以选择按照你自己喜欢的方式来命名,但是建议最好不要\n如果后面无论是开发环境,测试环境,生成环境都需要用到同一个配置参数.\n你可以继承\nclass DevelopmentConfig(DefaultConfig):\n    DEBUG&#x3D;True\n\n\n\n\n从配置文件中加载\napp.config.from_pyfile(配置文件)\n新建一个配置文件setting.py(命名最好可以区分开来这个是那个环境的配置文件)\n在Flask程序文件中\napp &#x3D; Flask(__name__)\n\napp.config.from_pyfile(&#39;setting.py&#39;)\n\n@app.route(&quot;&#x2F;&quot;)\ndef index():\n    print(app.config[&#39;SECRET_KEY&#39;])\n    return &quot;hello world&quot;\n\n\n\n\n\n\n\n提示\n在项目中使用固定的配置文件\n\n\n\n从环境变量中加载\n\n\n\n\n\n\n提示\n环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数,如:临时文件夹位置和系统文件夹位置等. 环境变量是在操作系统中一个具有特定名字的对象,它包含了一个或者多个应用程序所将使用到的信息.\n\n\n通俗的理解,环境变量就是我们设置在操作系统中,由操作系统代为保存的变量值\n在Linux系统中设置和读取配置环境变量的方法如下:\nexport 变量名&#x3D;变量值  # 设置\necho $变量名  # 读取\n\n# 例如\nexport ILOVE&#x3D;python\necho $ILOVE\n\nFlask使用环境变量加载配置的本质是通过环境变量值找到配置文件,再读取配置文件的信息,其使用方式为\napp.config.from_envvar(&#39;环境变量名&#39;)\n环境变量的值为配置文件的绝对路径\n先在终端中执行如下命令\nexport PROJECT_SETTING&#x3D;&#39;~&#x2F;setting.py&#39;\n\n再运行如下代码\napp &#x3D; Flask(__name__)\n\napp.config.from_envvar(&#39;PROJECT_SETTING&#39;, silent&#x3D;True)\n\n@app.route(&quot;&#x2F;&quot;)\ndef index():\n    print(app.config[&#39;SECRET_KEY&#39;])\n    return &quot;hello world&quot;\n\n\n\n\n\n\n\n提示\n关于silent的说明:\n表示系统环境变量中没有设置相应值时是否抛出异常\nFalse表示不安静处理,没有值时报错通知,默认为False\nTrue表示安静处理,即使没有值也让Flask正常的运行下去\n主要的应用场景:\n配置文件的地址不确定\n在代码中不想暴露真实的配置文件地址,只在运行代码的服务器上才有真实配置文件的信息.\n\n\n\n\n项目中的常用方式使用工厂模式创建Flask app,并结合使用配置对象与环境变量加载配置\n\n使用配置对象加载默认配置\n使用环境变量加载不想出现在代码中的敏感配置信息\n\ndef create_flask_app(config):\n    &quot;&quot;&quot;\n    创建Flask应用\n    :param config: 配置对象\n    :return: Flask应用\n    &quot;&quot;&quot;\n    app &#x3D; Flask(__name__)\n    app.config.from_object(config)\n\n    app.config.from_envvar(&quot;PROJECT_SETTING&quot;, silent&#x3D;True)\n    return app\n\nclass DefaultConfig(object):\n    &quot;&quot;&quot;默认配置&quot;&quot;&quot;\n    SECRET_KEY &#x3D; &#39;秘钥&#39;\n\nclass DevelopmentConfig(DefaultConfig):\n    DEBUG&#x3D;True\n\n# app &#x3D; create_flask_app(DefaultConfig)\napp &#x3D; create_flask_app(DevelopmentConfig)\n\n@app.route(&quot;&#x2F;&quot;)\ndef index():\n    print(app.config[&#39;SECRET_KEY&#39;])\n    return &quot;hello world&quot;\n\n\n\n\n\n\n\n\n注意\n从环境变量指向的配置文件中读取的配置信息会覆盖掉从配置对象中加载的同名参数\n\n\napp.run参数可以指定运行的主机IP地址,端口,是否开启调试模式\napp.run(host&#x3D;&quot;0.0.0.0&quot;, port&#x3D;5000, debug &#x3D; True)\n\n关于DEBUG调试模式\n\n程序代码修改后可以自动重启服务器\n在服务器出现相关错误的时候可以直接将错误信息返回到前端进行展示\n\n\n关于开发服务器的启动方式在1.0版本之后，Flask调整了开发服务器的启动方式，由代码编写app.run()语句调整为命令flask run启动。\nfrom flask import Flask\n\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;Hello World&#39;\n\n# 程序中不用再写app.run()\n\n终端启动$ export FLASK_APP&#x3D;helloworld\n$ flask run\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;\n\n\n\n\n\n\n\n提示\n\n环境变量 FLASK_APP 指明flask的启动实例\n\nflask run -h 0.0.0.0 -p 5000 绑定地址 端口\n\nflask run --help获取帮助\n\n生产模式与开发模式的控制\n通过FLASK_ENV环境变量指明\n\nexport FLASK_ENV=production 运行在生产模式,未指明则默认为此方式\nexport FLASK_ENV=development运行在开发模式\n\n\n\n扩展\n$ export FLASK_APP&#x3D;helloworld\n$ python -m flask run\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;\n\n\n\n\n","slug":"运行一个简单的Flask","date":"2021-09-25T15:55:49.000Z","categories_index":"文章","tags_index":"flask,python","author_index":"X"},{"id":"1c142a664bfa88741686fad34c20f543","title":"Flask简介","content":"诞生时间:Flask诞生于2010年，是Armin ronacher（人名）用 Python 语言基于 Werkzeug工具箱编写的轻量级Web开发框架。\n关于FlaskFlask两个核心\nWerkzeug工具箱\nJinja2模板引擎\n\n\n\n\n\n\n\n\n\n提示\n由于Flask没有提供额外的其他功能,所以几乎所有的功能都要用到扩展实现\n\nFlask常用扩展包\nFlask-SQLalchemy 操作数据库 \nFlask-script 插入脚本 \nFlask-migrate 管理迁移数据库 \nFlask-Session Session存储方式指定 \nFlask-WTF 表单 \nFlask-Mail 邮件 \nFlask-Bable 提供国际化和本地化支持,翻译 \nFlask-Login 认证用户状态 \nFlask-OpenID 认证 \nFlask-RESTful 开发REST API的工具 \nFlask-Bootstrap 集成前端Twitter Bootstrap框架 \nFlask-Moment 本地化日期和时间 \nFlask-Admin 简单而可扩展的管理接口的框架 \n\n\n\n\n\n\n\n\n提示\n更多扩展列表\n\n","slug":"Flask简介","date":"2021-09-23T14:48:23.000Z","categories_index":"文章","tags_index":"flask,python","author_index":"X"}]